<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ownphys</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            padding: 20px;
            margin: 0;
        }
        
        #svg-container {
            width: 90vmin;
            height: 90vmin;
            background-color: #f5f7fa;
            border-radius: 10px;
            overflow: hidden;
        } 
        
        .node {
            cursor: pointer;
            transition: fill 0.3s;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #6ab0de;
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: 1000;
            justify-content: center;
            overflow: visible;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px 30px;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            text-align: center;
            max-width: 500px;
            width: 80%;
            margin: 0 auto;
            transform: translateY(-100%);
            transition: transform 0.4s ease-out;
        }
        
        .modal-overlay.show {
            display: flex;
            height: auto;
        }
        
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }
        
        .modal-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .modal-button {
            padding: 8px 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .modal-button.confirm {
            background-color: #6ab0de;
            color: white;
        }
        
        .modal-button.confirm:hover {
            background-color: #5a9fc9;
        }
        
        .modal-button.back {
            background-color: #e0e0e0;
            color: #555;
        }
        
        .modal-button.back:hover {
            background-color: #d0d0d0;
        }

        /* 添加样式类用于激活状态 */
        .node-active {
            fill: #F5D060;
        }
        
        .node-inactive {
            fill: #6ab0de;
        }
        
        .edge-active {
            stroke: #F5D060;
            stroke-width: 4;
        }
        
        .edge-inactive {
            stroke: #6ab0de;
            stroke-width: 2;
        }
        
        .triangle-active {
            fill: #6E550B;
        }
        
        .triangle-inactive {
            fill: #131B7B;
        }
    </style>
</head>
<body>
    <div id="svg-container"></div>
    <div id="loading" class="loading">加载中...</div>

    <!-- 添加模态框HTML结构 -->
    <div id="modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">簇信息</div>
            <p id="cluster-info">簇详细信息将在这里显示</p>
            <div class="modal-buttons">
                <button id="confirm-button" class="modal-button confirm">确认</button>
                <button id="back-button" class="modal-button back">返回</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svgContainer = document.getElementById('svg-container');
            const loadingElement = document.getElementById('loading');
            
            // 获取模态框元素
            const modal = document.getElementById('modal');
            const confirmButton = document.getElementById('confirm-button');
            const backButton = document.getElementById('back-button');
            const clusterInfo = document.getElementById('cluster-info');
            
            //创建SVG元素
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svgContainer.appendChild(svg);

            // 节点和边的数据结构
            let nodes = [];
            let edges = [];
            let clusters = [];
            let activeNodes = new Set();
            let activeEdges = new Set();
            let lastClickedNode = null;
            let activeCluster = null; // 声明activeCluster变量
            
            // 存储SVG元素引用
            let nodeElements = new Map();
            let edgeLineElements = new Map();
            let triangleElements = new Map();
            let textElements = new Map();
            let animateElements = new Map();

            // 为模态框按钮添加事件监听
            confirmButton.addEventListener('click', handleConfirm);
            backButton.addEventListener('click', hideModal);
            
            // 处理确认按钮点击
            function handleConfirm() {
                if (activeCluster && activeCluster.url) {
                    window.open(activeCluster.url, '_blank');
                }
                hideModal();
            }
            
            // 加载数据
            async function loadData() {
                try {
                    // 加载节点数据
                    const nodesResponse = await fetch('nodes.json');
                    nodes = await nodesResponse.json();
                    
                    // 加载边数据
                    const edgesResponse = await fetch('edges.json');
                    edges = await edgesResponse.json();
                    
                    // 加载簇数据
                    const clustersResponse = await fetch('clusters.json');
                    clusters = await clustersResponse.json();
                    
                    // 隐藏加载提示
                    loadingElement.style.display = 'none';
                    
                    // 初始化图形
                    initialize();
                } catch (error) {
                    console.error('加载数据失败:', error);
                    loadingElement.textContent = '加载失败，请刷新页面重试';
                }
            }
            
            // 初始化节点和边
            function initialize() {
                // 居中放置节点
                const containerWidth = svgContainer.offsetWidth;
                const containerHeight = svgContainer.offsetHeight;

                // 将相对坐标转换为绝对坐标
                nodes.forEach(node => {
                    node.x = node.x * containerWidth;
                    node.y = node.y * containerHeight;
                });
                
                clearAllActivations();
                createGraphElements();
            }
            
            // 创建图形元素（只在初始化时调用）
            function createGraphElements() {
                // 清空SVG
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
                
                // 清空元素引用
                nodeElements.clear();
                edgeLineElements.clear();
                triangleElements.clear();
                textElements.clear();
                animateElements.clear();
                
                // 绘制边
                edges.forEach(edge => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    const targetNode = nodes.find(n => n.id === edge.target);
                    
                    if (sourceNode && targetNode) {
                        // 绘制线段
                        const line = document.createElementNS(svgNS, "line");
                        line.setAttribute("x1", sourceNode.x);
                        line.setAttribute("y1", sourceNode.y);
                        line.setAttribute("x2", targetNode.x);
                        line.setAttribute("y2", targetNode.y);
                        line.setAttribute("class", "edge-line edge-inactive");
                        svg.appendChild(line);
                        edgeLineElements.set(edge.id, line);
                        
                        // 计算边的角度
                        const angle = calculateAngle(sourceNode.x, sourceNode.y, targetNode.x, targetNode.y);
                        
                        // 创建移动的三角形
                        const triangleGroup = document.createElementNS(svgNS, "g");
                        triangleGroup.setAttribute("class", "triangle-group");
                        
                        // 创建三角形路径
                        const triangle = document.createElementNS(svgNS, "path");
                        triangle.setAttribute("d", "M0,-5 L10,0 L0,5 Z");
                        triangle.setAttribute("class", "triangle-path triangle-inactive");
                        triangle.setAttribute("transform", `rotate(${angle})`);
                        
                        // 添加动画
                        const animate = document.createElementNS(svgNS, "animateMotion");
                        animate.setAttribute("dur", "3s");
                        animate.setAttribute("repeatCount", "indefinite");
                        animate.setAttribute("path", `M${sourceNode.x},${sourceNode.y} L${targetNode.x},${targetNode.y}`);
                        animate.setAttribute("keyPoints", "0;1");
                        animate.setAttribute("keyTimes", "0;1");
                        animate.setAttribute("calcMode", "linear");
                        
                        triangleGroup.appendChild(triangle);
                        triangleGroup.appendChild(animate);
                        svg.appendChild(triangleGroup);
                        
                        triangleElements.set(edge.id, triangle);
                        animateElements.set(edge.id, animate);
                    }
                });
                
                // 绘制节点
                nodes.forEach(node => {
                    const circle = document.createElementNS(svgNS, "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "20");
                    circle.setAttribute("class", "node node-inactive");
                    circle.setAttribute("stroke", "white");
                    circle.setAttribute("stroke-width", "3");
                    circle.setAttribute("data-id", node.id);
                    
                    // 添加点击事件
                    circle.addEventListener("click", () => handleNodeClick(node));
                    
                    svg.appendChild(circle);
                    nodeElements.set(node.id, circle);
                    
                    // 添加节点标签
                    const text = document.createElementNS(svgNS, "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y + 5);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("fill", "white");
                    text.setAttribute("font-size", "14");
                    text.setAttribute("font-weight", "bold");
                    text.setAttribute("pointer-events", "none");
                    text.textContent = node.id;
                    svg.appendChild(text);
                    textElements.set(node.id, text);
                });
            }
            
            // 计算两点之间的角度
            function calculateAngle(x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
            }
            
            // 更新图形（只更新激活状态）
            function renderGraph() {
                // 更新节点样式
                nodes.forEach(node => {
                    const circle = nodeElements.get(node.id);
                    if (circle) {
                        if (activeNodes.has(node.id)) {
                            circle.classList.remove("node-inactive");
                            circle.classList.add("node-active");
                        } else {
                            circle.classList.remove("node-active");
                            circle.classList.add("node-inactive");
                        }
                    }
                });
                
                // 更新边样式
                edges.forEach(edge => {
                    const line = edgeLineElements.get(edge.id);
                    const triangle = triangleElements.get(edge.id);
                    const animate = animateElements.get(edge.id);
                    
                    if (line && triangle && animate) {
                        if (activeEdges.has(edge.id)) {
                            line.classList.remove("edge-inactive");
                            line.classList.add("edge-active");
                            
                            triangle.classList.remove("triangle-inactive");
                            triangle.classList.add("triangle-active");
                            
                            animate.setAttribute("dur", "2s");
                        } else {
                            line.classList.remove("edge-active");
                            line.classList.add("edge-inactive");
                            
                            triangle.classList.remove("triangle-active");
                            triangle.classList.add("triangle-inactive");
                            
                            animate.setAttribute("dur", "3s");
                        }
                    }
                });
                
                // 检查是否只剩下一个簇被选中
                checkSingleCluster();
            }
            
            // 处理节点点击
            function handleNodeClick(node) {
                // 如果连续两次点击同一个节点
                if (lastClickedNode === node.id) {
                    clearAllActivations();
                    lastClickedNode = null;
                } else {
                    // 如果节点已经激活，显示所有相关的簇
                    if (activeNodes.has(node.id)) {
                        activateAllClustersForNode(node.id);
                    } else {
                        // 节点未激活，激活节点及其连接
                        clearAllActivations();
                        activateNodeAndConnections(node.id);
                    }
                    lastClickedNode = node.id;
                }
                renderGraph();
            }
            
            // 检查是否只剩下一个簇被选中
            function checkSingleCluster() {
                // 获取所有被激活的边
                const activatedEdgeIds = Array.from(activeEdges);
                
                // 找出包含这些边的簇
                const activatedClusters = clusters.filter(cluster => {
                    // 检查簇中的所有边是否都被激活
                    return cluster.edges.every(edgeId => activatedEdgeIds.includes(edgeId));
                });
                
                // 如果只有一个簇被完全激活
                if (activatedClusters.length === 1) {
                    activeCluster = activatedClusters[0];
                    showModal();
                }
            }
            
            // 显示弹窗
            function showModal() {
                if (activeCluster) {
                    clusterInfo.textContent = `已选择簇: ${activeCluster.id}`;
                    modal.classList.add('show');
                }
            }
            
            // 隐藏弹窗
            function hideModal() {
                modal.classList.remove('show');
            }
            
            // 激活节点及其连接
            function activateNodeAndConnections(nodeId) {
                activeNodes.add(nodeId);
                
                // 找到所有连接的边并激活
                edges.forEach(edge => {
                    if (edge.source === nodeId || edge.target === nodeId) {
                        activeEdges.add(edge.id);
                        
                        // 激活连接的节点
                        if (edge.source === nodeId) {
                            activeNodes.add(edge.target);
                        } else {
                            activeNodes.add(edge.source);
                        }
                    }
                });
            }
            
            // 清除所有激活状态
            function clearAllActivations() {
                activeNodes.clear();
                activeEdges.clear();
                activeCluster = null;
            }
            
            // 激活所有相关的簇
           function activateAllClustersForNode(nodeId) {
                // 找到所有连接该节点的边
                const connectedEdges = edges.filter(edge => 
                    edge.source === nodeId || edge.target === nodeId
                );
                
                // 找到这些边中被激活的边
                const activeConnectedEdges = connectedEdges.filter(edge => 
                    activeEdges.has(edge.id)
                );
                
                // 找到这些被激活的边所在的所有的簇
                const relatedClusters = [];
                activeConnectedEdges.forEach(edge => {
                    clusters.forEach(cluster => {
                        if (cluster.edges.includes(edge.id) && !relatedClusters.includes(cluster)) {
                            relatedClusters.push(cluster);
                        }
                    });
                });
                clearAllActivations();
                
                // 激活所有相关簇中的节点和边
                relatedClusters.forEach(cluster => {
                    cluster.edges.forEach(edgeId => activeEdges.add(edgeId));
                    cluster.nodes.forEach(nodeId => activeNodes.add(nodeId));
                });
            }
            
            // 开始加载数据
            loadData();
            
            // 添加窗口大小调整事件
            window.addEventListener('resize', function() {
                if (nodes.length > 0) {
                    initialize();
                }
            });
        });
    </script>
</body>
</html>
