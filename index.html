<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>节点簇交互可视化</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            padding: 20px;
            margin: 0;
        }
        
        #svg-container {
            width: 90vmin;
            height: 90vmin;
            background-color: #f5f7fa;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        } 
        
        .node {
            cursor: pointer;
            transition: fill 0.3s;
        }
        
        .triangle-path {
            filter: url(#blur-filter);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #6ab0de;
        }
        
        /* 弹窗样式 */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            text-align: center;
            max-width: 400px;
            width: 80%;
        }
        
        .modal-title {
            font-size: 20px;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .modal-button.confirm {
            background-color: #6ab0de;
            color: white;
        }
        
        .modal-button.confirm:hover {
            background-color: #5a9fc9;
        }
        
        .modal-button.back {
            background-color: #e0e0e0;
            color: #555;
        }
        
        .modal-button.back:hover {
            background-color: #d0d0d0;
        }
    </style>
</head>
<body>
    <div id="svg-container"></div>
    <div id="loading" class="loading">加载中...</div>

    <!-- 弹窗结构 -->
    <div id="modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">簇选择完成</div>
            <p id="cluster-info">您已成功选择一个完整的簇，点击确认按钮将跳转到相关页面。</p>
            <div class="modal-buttons">
                <button id="confirm-button" class="modal-button confirm">确认</button>
                <button id="back-button" class="modal-button back">返回</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svgContainer = document.getElementById('svg-container');
            const loadingElement = document.getElementById('loading');
            
            // 获取弹窗元素
            const modal = document.getElementById('modal');
            const confirmButton = document.getElementById('confirm-button');
            const backButton = document.getElementById('back-button');
            const clusterInfo = document.getElementById('cluster-info');
            
            // 创建SVG元素
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svgContainer.appendChild(svg);

            // 添加模糊滤镜效果
            const defs = document.createElementNS(svgNS, "defs");
            const filter = document.createElementNS(svgNS, "filter");
            filter.setAttribute("id", "blur-filter");
            const blur = document.createElementNS(svgNS, "feGaussianBlur");
            blur.setAttribute("in", "SourceGraphic");
            blur.setAttribute("stdDeviation", "2");
            filter.appendChild(blur);
            defs.appendChild(filter);
            svg.appendChild(defs);
            
            // 节点和边的数据结构
            let nodes = [];
            let edges = [];
            let clusters = [];
            let activeNodes = new Set();
            let activeEdges = new Set();
            let lastClickedNode = null;
            let activeCluster = null;
            
            // 弹窗事件处理
            confirmButton.addEventListener('click', function() {
                if (activeCluster && activeCluster.url) {
                    window.location.href = activeCluster.url;
                } else {
                    hideModal();
                }
            });
            
            backButton.addEventListener('click', hideModal);
            
            // 显示弹窗
            function showModal() {
                if (activeCluster) {
                    clusterInfo.textContent = `您已选择簇 ${activeCluster.id}，点击确认将跳转到相关页面。`;
                    modal.style.display = 'flex';
                }
            }
            
            // 隐藏弹窗
            function hideModal() {
                modal.style.display = 'none';
            }
            
            // 加载数据
            async function loadData() {
                try {
                    // 加载节点数据
                    const nodesResponse = await fetch('nodes.json');
                    nodes = await nodesResponse.json();
                    
                    // 加载边数据
                    const edgesResponse = await fetch('edges.json');
                    edges = await edgesResponse.json();
                    
                    // 加载簇数据
                    const clustersResponse = await fetch('clusters.json');
                    clusters = await clustersResponse.json();
                    
                    // 隐藏加载提示
                    loadingElement.style.display = 'none';
                    
                    // 初始化图形
                    initialize();
                } catch (error) {
                    console.error('加载数据失败:', error);
                    loadingElement.textContent = '加载失败，请刷新页面重试';
                }
            }
            
            // 初始化节点和边
            function initialize() {
                // 居中放置节点
                const containerWidth = svgContainer.offsetWidth;
                const containerHeight = svgContainer.offsetHeight;

                // 将相对坐标转换为绝对坐标
                nodes.forEach(node => {
                    node.x = node.x * containerWidth;
                    node.y = node.y * containerHeight;
                });
                
                clearAllActivations();
                renderGraph();
            }
            
            // 计算两点之间的角度
            function calculateAngle(x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
            }
            
            // 渲染图形
            function renderGraph() {
                // 清空SVG，但保留defs
                const defsElement = svg.querySelector('defs');
                while (svg.childNodes.length > 1) {
                    if (svg.lastChild !== defsElement) {
                        svg.removeChild(svg.lastChild);
                    } else {
                        break;
                    }
                }
                
                // 绘制边
                edges.forEach(edge => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    const targetNode = nodes.find(n => n.id === edge.target);
                    
                    if (sourceNode && targetNode) {
                        // 绘制线段
                        const line = document.createElementNS(svgNS, "line");
                        line.setAttribute("x1", sourceNode.x);
                        line.setAttribute("y1", sourceNode.y);
                        line.setAttribute("x2", targetNode.x);
                        line.setAttribute("y2", targetNode.y);
                        line.setAttribute("stroke", activeEdges.has(edge.id) ? "#F5D060" : "#6ab0de");
                        line.setAttribute("stroke-width", activeEdges.has(edge.id) ? "4" : "2");
                        line.setAttribute("class", "edge-line");
                        svg.appendChild(line);
                        
                        // 计算边的长度和角度
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const angle = calculateAngle(sourceNode.x, sourceNode.y, targetNode.x, targetNode.y);
                        const length = Math.sqrt(dx * dx + dy * dy);
                        
                        // 创建移动的三角形
                        const triangleGroup = document.createElementNS(svgNS, "g");
                        triangleGroup.setAttribute("class", "triangle-group");
                        
                        // 创建三角形路径
                        const triangle = document.createElementNS(svgNS, "path");
                        triangle.setAttribute("d", "M0,-5 L10,0 L0,5 Z");
                        triangle.setAttribute("fill", activeEdges.has(edge.id) ? "#6E550B" : "#131B7B");
                        triangle.setAttribute("class", "triangle-path");
                        triangle.setAttribute("transform", `rotate(${angle})`);
                        
                        // 添加动画
                        const animate = document.createElementNS(svgNS, "animateMotion");
                        animate.setAttribute("dur", activeEdges.has(edge.id) ? "2s" : "3s");
                        animate.setAttribute("repeatCount", "indefinite");
                        animate.setAttribute("path", `M${sourceNode.x},${sourceNode.y} L${targetNode.x},${targetNode.y}`);
                        animate.setAttribute("keyPoints", "0;1");
                        animate.setAttribute("keyTimes", "0;1");
                        animate.setAttribute("calcMode", "linear");
                        
                        triangleGroup.appendChild(triangle);
                        triangleGroup.appendChild(animate);
                        svg.appendChild(triangleGroup);
                    }
                });
                
                // 绘制节点
                nodes.forEach(node => {
                    const circle = document.createElementNS(svgNS, "circle");
                    circle.setAttribute("cx", node.x);
                    circle.setAttribute("cy", node.y);
                    circle.setAttribute("r", "20");
                    circle.setAttribute("fill", activeNodes.has(node.id) ? "#F5D060" : "#6ab0de");
                    circle.setAttribute("stroke", "white");
                    circle.setAttribute("stroke-width", "3");
                    circle.setAttribute("data-id", node.id);
                    circle.setAttribute("class", "node");
                    
                    // 添加点击事件
                    circle.addEventListener("click", () => handleNodeClick(node));
                    
                    svg.appendChild(circle);
                    
                    // 添加节点标签
                    const text = document.createElementNS(svgNS, "text");
                    text.setAttribute("x", node.x);
                    text.setAttribute("y", node.y + 5);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("fill", "white");
                    text.setAttribute("font-size", "14");
                    text.setAttribute("font-weight", "bold");
                    text.setAttribute("pointer-events", "none");
                    text.textContent = node.id;
                    svg.appendChild(text);
                });
            }
            
            // 处理节点点击
            function handleNodeClick(node) {
                // 如果连续两次点击同一个节点
                if (lastClickedNode === node.id) {
                    clearAllActivations();
                    lastClickedNode = null;
                } else {
                    // 如果节点已经激活，显示所有相关的簇
                    if (activeNodes.has(node.id)) {
                        activateAllClustersForNode(node.id);
                    } else {
                        // 节点未激活，激活节点及其连接
                        clearAllActivations();
                        activateNodeAndConnections(node.id);
                    }
                    lastClickedNode = node.id;
                    checkSingleCluster();
                }
                renderGraph();
            }
            
            // 检查是否只剩下一个簇被选中
            function checkSingleCluster() {
                // 获取所有被激活的边
                const activatedEdgeIds = Array.from(activeEdges);
                
                // 找出包含这些边的簇
                const activatedClusters = clusters.filter(cluster => {
                    // 检查簇中的所有边是否都被激活
                    return cluster.edges.every(edgeId => activatedEdgeIds.includes(edgeId));
                });
                
                // 如果只有一个簇被完全激活
                if (activatedClusters.length === 1) {
                    activeCluster = activatedClusters[0];
                    showModal();
                }
            }
            
            // 激活节点及其连接
            function activateNodeAndConnections(nodeId) {
                activeNodes.add(nodeId);
                
                // 找到所有连接的边并激活
                edges.forEach(edge => {
                    if (edge.source === nodeId || edge.target === nodeId) {
                        activeEdges.add(edge.id);
                        
                        // 激活连接的节点
                        if (edge.source === nodeId) {
                            activeNodes.add(edge.target);
                        } else {
                            activeNodes.add(edge.source);
                        }
                    }
                });
            }
            
            // 清除所有激活状态
            function clearAllActivations() {
                activeNodes.clear();
                activeEdges.clear();
                activeCluster = null;
                hideModal();
            }
            
            // 激活所有相关的簇
           function activateAllClustersForNode(nodeId) {
                // 找到所有连接该节点的边
                const connectedEdges = edges.filter(edge => 
                    edge.source === nodeId || edge.target === nodeId
                );
                
                // 找到这些边中被激活的边
                const activeConnectedEdges = connectedEdges.filter(edge => 
                    activeEdges.has(edge.id)
                );
                
                // 找到这些被激活的边所在的所有的簇
                const relatedClusters = [];
                activeConnectedEdges.forEach(edge => {
                    clusters.forEach(cluster => {
                        if (cluster.edges.includes(edge.id) && !relatedClusters.includes(cluster)) {
                            relatedClusters.push(cluster);
                        }
                    });
                });
                clearAllActivations();
                
                // 激活所有相关簇中的节点和边
                relatedClusters.forEach(cluster => {
                    cluster.edges.forEach(edgeId => activeEdges.add(edgeId));
                    cluster.nodes.forEach(nodeId => activeNodes.add(nodeId));
                });
            }
            
            // 开始加载数据
            loadData();
            
            // 添加窗口大小调整事件
            window.addEventListener('resize', function() {
                if (nodes.length > 0) {
                    initialize();
                }
            });
        });
    </script>
</body>
</html>
