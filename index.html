<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>分层网络图交互高亮功能</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
        }
        #graph {
            width: 100%;
            height: 100%;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .node {
            stroke: #f7f7f2;
            stroke-width: 1px;
            cursor: pointer;
            transition: r 0.3s ease, fill 0.3s ease;
        }
        .node:hover {
            stroke: #ff9f43;
            stroke-width: 3px;
        }
        .link {
            stroke-opacity: 0.8;
            transition: stroke-opacity 0.3s ease, stroke-width 0.3s ease;
        }
        .upper-link {
            stroke-dasharray: 5,5;
            stroke-opacity: 0.4;
            stroke-width: 1.5;
        }
        .node-label {
            font-size: 12px;
            fill: #333;
            text-shadow: 0 1px 3px rgba(255,255,255,0.7);
            pointer-events: none;
            transition: font-size 0.3s ease;
        }
        .upper-node-label {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
            text-shadow: 0 1px 4px rgba(255,255,255,0.7);
            opacity: 0.7;
        }
        .instructions {
            text-align: center;
            color: #666;
            margin: 10px 0;
            font-size: 16px;
        }
        .highlight {
            color: #ff9f43;
            font-weight: bold;
        }
        .toggle-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background-color: #2073c7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
        }
        .toggle-button:hover {
            background-color: #1a5fa3;
        }
    </style>
</head>
<body>
    <button class="toggle-button" id="toggleHiddenNodes">显示隐藏节点</button>
    <div class="container">
        <div class="visualization">
            <svg id="graph"></svg>
        </div>
    </div>

    <script type="module">
        // 导入外部数据文件和工具函数
        import { visNodes } from './visNodes.js';
        import { visLinks } from './visLinks.js';
        import { conditions } from './conditions.js';
        import { clusters } from './clusters.js';
        
        // 导入jiggle函数，用于处理零值情况
        function jiggle(random) {
            return (random() - 0.5) * 1e-6;
        }

            function oneWayLinkForce() {
            // 默认阻尼系数设为0.1，范围建议在0-1之间
            const damping = 0.5;
            
            return function(alpha) {
                for (const link of visLinks) {
                    const source = link.source;
                    const target = link.target;
                    const distance = link.distance || 100;
                    
                    if (!target || typeof target.x !== 'number' || typeof target.y !== 'number') {
                        continue;
                    }
                    
                    if (source.layer === -1 || source.layer === -2){
                        // 计算节点间向量（包含速度）
                        let x = target.x + target.vx - source.x - source.vx || jiggle(Math.random);
                        let y = target.y + target.vy - source.y - source.vy || jiggle(Math.random);
                        // 计算向量长度
                        let l = Math.sqrt(x * x + y * y);
                        // 计算力的大小 = (当前长度 - 目标长度) / 当前长度 * 衰减系数 * 强度系数
                        l = (l - distance) / l * damping * alpha;
                        // 应用力的大小到向量分量
                        x *= l, y *= l;
                        // 单向力只应用于source节点
                        source.vx += x;
                        source.vy += y;
                    }
                }
            };
        }

        // 设置尺寸和边距
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const color = ['#CE8D79','#88B07E','#9D87AC','#7ed6df']//-2 -1 0 1 

        // 创建SVG元素
        let svg = d3.select('#graph')
            .attr('width', width)
            .attr('height', height);

        // 添加缩放容器
        let container = svg.append('g')
            .attr('class', 'container');

        // 全局defs变量
        let defs;

        const unifiedNodeColor = '#2073c7'; // 统一所有一层节点颜色
        
        // 下层连接线统一颜色
        const lowerLinkColor = '#7ed6df';
        const grayArrowColor = '#999'; 

        // 全局变量
        let simulation;
        let hiddenNodesVisible = false;
        // 存储所有高亮的节点和连接
        let hLNodes = new Set();
        let hLLinks = new Set();
        // 存储上一次点击的节点信息
        let lastClickedNode = null;


    // 创建可复用的箭头标记模板函数
        function createArrow(id, defaultColor) {
            return defs.append('marker')
                .attr('id', id)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 40)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('class', 'arrow-head')
                .attr('fill', defaultColor);
        }
        function sameArrow(linkColor){
            // 创建特定颜色的箭头标记
            const markerId = 'arrowhead-' + d3.color(linkColor).formatHex().replace('#', '');
                    
            // 检查是否已经创建过相同颜色的箭头标记
            if (!defs.select(`#${markerId}`).empty()) {
                return `url(#${markerId})`;
            }
            createArrow(markerId, linkColor)
            return `url(#${markerId})`;
        }



        // 初始化图
        function initializeGraph() {
            // 清除现有的图
            d3.select("#graph").selectAll("*").remove();
            
            // 重新创建SVG元素
            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            // 重新创建缩放容器
            container = svg.append('g')
                .attr('class', 'container');

            // 添加箭头标记定义
            defs = svg.append('defs');

            // 创建基础箭头标记（不设置固定颜色，将在使用时动态设置）
            createArrow('arrowhead-highlight', '#000');
            
            // 创建灰色箭头标记（用于未激活状态）
            createArrow('arrowhead-gray', grayArrowColor);

            return { svg, container };
        }

        function filteredLinks() {
            return visLinks.filter(link => {
                if (link.isHiddenLink && ! hiddenNodesVisible) {
                    return false;
                    }               
                return true}
            )};
        
        // 全局变量，用于跟踪是否为第一次创建模拟
        let isFirstSimulation = true;
        
        // 创建力导向图模拟
        function createSimulation(visNodes) {
            
            // 为每个节点设置初始坐标为relX*width和relY*height（仅在第一次创建模拟时执行）
            if (isFirstSimulation) {
                visNodes.forEach(node => {
                    if (node.relX !== undefined && node.relY !== undefined) {
                        node.x = width * node.relX;
                        node.y = height * node.relY;
                    }
                });
                isFirstSimulation = false;
            }
             
            const nodeById = new Map(visNodes.map(n => [n.id, n]));

            const nonHiddenLinks = filteredLinks().map(link => {
            // 如果 source/target 还是 id，就替换为 node 对象
            if (typeof link.source !== "object") link.source = nodeById.get(link.source);
            if (typeof link.target !== "object") link.target = nodeById.get(link.target);
            return link;
            }).filter(link => {
            // 同时检查 source 和 target
            return !(
                (link.source.layer === -1 || link.source.layer === -2) ||
                (link.target.layer === -1 || link.target.layer === -2)
            );
            });

            
            // 创建力导向图 - 使用自定义力
            const sim = d3.forceSimulation(visNodes)
                .force('link', d3.forceLink(nonHiddenLinks).distance(d => {
                    if (d.upper) return 200;
                    if (d.source.layer === 0) return 150; // 修改为仅检查layer=0
                    return 100;  
                }))
                // 添加单向链接力
                .force('oneWayLink', oneWayLinkForce())
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('x', d3.forceX(width / 2).strength(0.04))
                .force('y', d3.forceX(height / 2).strength(0.03))
                .force('Charge', d3.forceManyBody().strength(d => {
                    if (d.layer === 1 ) return d.nodecharge; // 新节点不受电荷力
                    return 0;
                }).distanceMax(300))
                .force('Collision', d3.forceCollide().radius(d => {
                    if (d.layer === 1) return 30; // 新节点不受碰撞力
                    return 0;
                }))
                // alpha相关设置
                .alpha(1)            // 初始alpha值
                .alphaMin(0.001)     // 最小alpha值
                .alphaDecay(0.1)  // alpha衰减率
                .alphaTarget(0);     // alpha目标值

                // 力导向图设置完成

            return sim;
        }

        // 绘制图
        function drawGraph() {
            // 初始化图
            const { svg, container } = initializeGraph();
            
            // 创建nodeById映射，用于在绘制连接线时查找节点
            const nodeById = new Map(visNodes.map(n => [n.id, n]));
            
            // 创建力导向图模拟
            simulation = createSimulation(visNodes);

            // 绘制连接线
            const link = container.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(filteredLinks())
                .enter()
                .append('line')
                .attr('class', d => d.upper ? 'upper-link link' : 'link')
                .attr('stroke', d => {
                    if (d.upper) return 'rgba(100, 100, 100, 0.5)';
                    else return color[d.source.layer+2];
                })
                .attr('stroke-width', d => d.upper ? 1.5 : 2)
                .attr('marker-end', d => {
                        if (d.upper) return null;
                        // 获取连接线颜色
                        const linkColor = d.upper ? 'rgba(100, 100, 100, 0.5)' : color[d.source.layer+2];
                        return sameArrow(linkColor)
                    });

            // 过滤掉不可见的节点
            const filteredNodes = visNodes.filter(node => {
                if ((node.layer === -1 || node.layer === -2) && !hiddenNodesVisible) {
                    return false;
                }
                return true;
            });

            // 绘制节点
            const node = container.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(filteredNodes)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', d => {
                    if (d.upper) return 18;
                    if (d.condition) return 12; // layer=0 节点大小
                    if (d.hidden1 || d.hidden2) return 10; // layer=-1/-2 节点大小
                    // 根据nodecharge决定半径
                    return Math.abs(d.nodecharge) === 300 ? 15 : 10;
                })
                .attr('fill', d => {
                    if (d.upper) return 'rgba(108, 92, 231, 0.2)';
                    if (d.layer === 1) return unifiedNodeColor; // layer=0 节点颜色
                    else return color[d.layer+2];
                })
                .attr('stroke', d => {
                    if (d.upper) return 'rgba(80, 80, 80, 0.1)';
                    if (d.condition || d.hidden1 || d.hidden2) return '#333';
                    return '#333';
                })
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));

            // 添加节点标签
            const label = container.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(filteredNodes)
                .enter()
                .append('text')
                .attr('class', d => {
                    if (d.upper) return 'upper-node-label node-label';
                    if (d.condition || d.hidden1 || d.hidden2) return 'node-label';
                    return 'node-label';
                })
                .text(d => d.name)
                .attr('text-anchor', 'middle')
                .attr('x', d =>  d.x)
                .attr('y', d => d.y)
                .attr('dy', d => {
                    if (d.upper) return -25;
                    if (d.condition) return -18; // layer=0 标签位置
                    if (d.hidden1 || d.hidden2) return -15; // layer=-1/-2 标签位置
                    // 根据nodecharge决定标签位置
                    return Math.abs(d.nodecharge) === 300 ? -20 : -15;
                });

            // 力导向图更新函数
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // 添加缩放功能（取消双击放大）
            const zoom = d3.zoom()
                .scaleExtent([0.2, 4])
                .on('zoom', (event) => {
                    container.attr('transform', event.transform);
                })
                .filter(event => {
                    // 取消双击缩放功能
                    if (event.type === 'dblclick') return false;
                    return true;
                });

            svg.call(zoom);



             // 添加点击事件
            node.on('click', (event, d) => {
                event.stopPropagation();
                console.log('Node clicked:', d);
                
                // 首先检查是否点击的是已高亮集群中的节点
                const clickedCluster = checkIfClickedClusterNode(d);
                if (clickedCluster) {
                    // 如果点击的是root节点，则进入URL
                    if (d.id === clickedCluster.roots) {
                        window.open(clickedCluster.url, '_blank');}
                    else if (clickedCluster.nodes.includes(d.id)){
                    // 如果点击的是集群里的其他节点，则恢复到高亮集群出现前的高亮状态
                        restorePreClusterhL();
                    }
                    return;
                }

                // 然后检查是否连续两次点击同一个节点
                if (lastClickedNode && lastClickedNode.id === d.id && lastClickedNode.layer!==0) {
                    // 取消周边节点的激活状态
                    unhLNeighbors(d);
                    lastClickedNode = null;
                    return;
                }
                hLRelevantNodes(d);
                
            }); 

            // 添加svg点击事件（重置高亮）
            svg.on('click', () => {
                resetSty();
            });

            
 
            // 高亮相关节点和连接
            function hLRelevantNodes(clickedNode) {
                // 检查是否两次连续点击到属于同一个集群的节点
                if (lastClickedNode && lastClickedNode !== clickedNode) {
                    // 查找当前点击节点所属的集群
                    const currentNodeCluster = clusters.find(cluster => cluster.nodes.includes(clickedNode.id));
                    // 查找上一次点击节点所属的集群
                    const lastNodeCluster = clusters.find(cluster => cluster.nodes.includes(lastClickedNode.id));
                    
                    // 如果两次点击的节点属于同一个集群
                    if (currentNodeCluster && lastNodeCluster && currentNodeCluster === lastNodeCluster) {
                        // 高亮整个集群
                        hLEntireCluster(currentNodeCluster);
                        // 更新上一次点击的节点
                        lastClickedNode = clickedNode;
                        return;
                    }
                }
                
                // 将当前点击的节点添加到高亮集合中
                if (clickedNode.upper) {
                    // 点击的是上层节点
                    hLUpperNode(clickedNode);
                } else if (clickedNode.layer === 1) {
                    // 点击的是下层节点
                    hLLowerNode(clickedNode);
                } else if (clickedNode.layer === 0) {
                    // 点击的是条件节点
                    hLCodNode(clickedNode);
                } else {
                    hLNewNode(clickedNode);
                }
                
                // 应用普通高亮效果
                applyHLSty();
                
                // 更新上一次点击的节点
                lastClickedNode = clickedNode;
            }


            // 高亮上层节点相关的节点和连接
            function hLUpperNode(upperNode) {
                // 找到与上层节点直接相连的下层节点
                const conLowerNodes = new Set();
                visLinks.forEach(link => {
                    if (link.source.id === upperNode.id && !link.target.upper) {
                        conLowerNodes.add(link.target.id);
                    }
                    if (link.target.id === upperNode.id && !link.source.upper) {
                        conLowerNodes.add(link.source.id);
                    }
                });

                // 找到与这些下层节点相连的其他上层节点
                const conUpperNodes = new Set([upperNode.id]);
                visLinks.forEach(link => {
                    if (conLowerNodes.has(link.source.id) && link.target.upper) {
                        conUpperNodes.add(link.target.id);
                    }
                    if (conLowerNodes.has(link.target.id) && link.source.upper) {
                        conUpperNodes.add(link.source.id);
                    }
                });

                // 将相关节点添加到全局高亮集合
                conLowerNodes.forEach(nodeId => hLNodes.add(nodeId));
                conUpperNodes.forEach(nodeId => hLNodes.add(nodeId));

                // 找到需要高亮的连接线并添加到全局高亮集合
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    // 检查是否与高亮节点相关
                    if (conLowerNodes.has(sourceId) && conLowerNodes.has(targetId)) {
                        hLLinks.add(link.id);
                    }
                    if (conUpperNodes.has(sourceId) && conLowerNodes.has(targetId)) {
                        hLLinks.add(link.id);
                    }
                    if (conUpperNodes.has(targetId) && conLowerNodes.has(sourceId)) {
                        hLLinks.add(link.id);
                    }
                });
            }

            // 高亮下层节点相关的节点和连接
            function hLLowerNode(lowerNode) {
                // 找到与下层节点直接相连的所有节点
                const conNodes = new Set([lowerNode.id]);
                visLinks.forEach(link => {
                    if (link.source.id === lowerNode.id) {
                        conNodes.add(link.target.id);
                    }
                    if (link.target.id === lowerNode.id) {
                        conNodes.add(link.source.id);
                    }
                });

                // 将相关节点添加到全局高亮集合
                conNodes.forEach(nodeId => hLNodes.add(nodeId));

                // 找到需要高亮的连接线并添加到全局高亮集合
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    if (conNodes.has(sourceId) && conNodes.has(targetId)) {
                        hLLinks.add(link.id);
                    }
                });
            }

            // 高亮新节点（layer=-1, -2）相关的节点和连接
            function hLNewNode(newNode) {
                // 找到与新节点直接相连的所有节点
                const conNodes = new Set([newNode.id]);
                visLinks.forEach(link => {
                    if (link.source.id === newNode.id) {
                        conNodes.add(link.target.id);
                    }
                    if (link.target.id === newNode.id) {
                        conNodes.add(link.source.id);
                    }
                });

                // 将相关节点添加到全局高亮集合
                conNodes.forEach(nodeId => hLNodes.add(nodeId));

                // 找到需要高亮的连接线并添加到全局高亮集合
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    if (conNodes.has(sourceId) && conNodes.has(targetId)) {
                        hLLinks.add(link.id);
                    }
                });
            }
            // 应用所有高亮样式
            function applyHLSty() {
                // 按照优先级执行检查：先检查线，再检查节点，最后检查是否需要重置
                validateHLLinks();  // 检查线
                validateHLNodes(); // 检查节点
                
                // 如果已经需要重置样式，直接返回
                if (checkResetSty()) {
                    return;
                }
                conLinks()
                
                    // 在 applyHLSty() 内替换 node.attr('fill', ...) 的回调逻辑为：
                    node.attr('fill', d => {
                        return getNodeCodColor(d.id);
                    })
                    .attr('r', d => {
                    if (hLNodes.has(d.id)) {
                        // 高亮节点稍微变大
                        if (d.upper) return 22;
                        if (d.condition) return 14;
                        if (d.hidden1 || d.hidden2) return 12;
                        return Math.abs(d.nodecharge) === 300 ? 18 : 13;
                    }
                    return d.upper ? 18 : (Math.abs(d.nodecharge) === 300 ? 15 : 10);
                    }).attr('stroke-width', d => {
                    if (hLNodes.has(d.id)) {
                        // 高亮节点增加边框宽度
                        return 3;
                    }
                    return 1;
                });
                
                // 高亮相关连接
                link
                    .style('stroke', l => {
                        if (hLLinks.has(l.id)) {
                            // 保持连接线原始颜色
                            if (l.upper) return '#ff9f43'; // 上层线高亮时变色
                            return color[l.source.layer+2]; // 非上层线高亮时保持原始颜色
                        } 
                        if (l.upper) return 'rgba(170, 170, 170, 0.2)';
                        return color[l.source.layer+2];
                        if (!hLLinks.has(l.id) )
                        return '#ccc'; 
                    })
                    .style('stroke-width', l => {
                        if(hLLinks.size === 0) return 3;
                        else if(!hLLinks.has(l.id) ) return l.upper ? 1.5 : 2;
                        return 3;
                    })
                    .style('stroke-opacity', l => {
                        if(hLLinks.size === 0) return 3;
                        else if(!hLLinks.has(l.id) ) return 0.2;
                        return 1;
                    })
                    .attr('marker-end', l => {
                        if (l.upper) return null;
                        
                        let linkColor;
                        if (hLLinks.size === 0) 
                        linkColor = l.upper ? '#ff9f43' : color[l.source.layer+2];
                        else if (!hLLinks.has(l.id) ) {
                            // 非高亮状态使用灰色
                            linkColor = grayArrowColor;
                        } else {
                            // 高亮状态下使用连接线的颜色
                            linkColor = l.upper ? '#ff9f43' : color[l.source.layer+2];
                        }
                        return sameArrow(linkColor)
                    });
            }
            
            // 保存高亮状态的数据结构
            let preClusterhLState = null;

            // 高亮整个集群
            function hLEntireCluster(cluster) {
                // 保存当前高亮状态，用于后续恢复
                preClusterhLState = {
                    hLNodes: new Set(hLNodes),
                    hLLinks: new Set(hLLinks),
                    tempHLNodes: new Set()
                };
                
                // 保存哪些节点有tempHL标记
                visNodes.forEach(node => {
                    if (node.tempHL) {
                        preClusterhLState.tempHLNodes.add(node.id);
                    }
                });
                
                // 清空高亮集合，准备高亮整个集群
                hLNodes.clear();
                hLLinks.clear();
                
                // 添加集群所有节点到高亮集合
                cluster.nodes.forEach(nodeId => hLNodes.add(nodeId));
                
                // 标记这些节点为集群高亮状态
                visNodes.forEach(node => {
                    node.tempHL = cluster.nodes.includes(node.id);
                });
                
                // 获取集群在clusters数组中的索引
                const clusterIndex = clusters.indexOf(cluster);
                
                // 添加与集群相关的连接到高亮集合
                visLinks.forEach(link => {
                    // 检查连接线的cluster数组是否包含当前集群的索引
                    if (link.cluster && link.cluster.includes(clusterIndex)) {
                        hLLinks.add(link.id);
                    }
                });
                
                // 应用集群高亮样式
                applyClusterHLSty();
            }

            // 应用集群高亮样式
            function applyClusterHLSty() {
                // 先验证高亮线的条件
                
                // 高亮相关节点
                node.attr('fill', d => {
                    if (d.tempHL) {
                        // 集群高亮时节点颜色变为明黄色
                        return '#ff9f43';
                    }
                    return '#ddd'; // 非高亮节点变为灰色
                }).attr('r', d => {
                    if (d.tempHL) {
                        // 高亮节点稍微变大
                        if (d.upper) return 22;
                        if (d.condition) return 14;
                        if (d.hidden1 || d.hidden2) return 12;
                        return Math.abs(d.nodecharge) === 300 ? 18 : 13;
                    }
                    return d.upper ? 18 : (Math.abs(d.nodecharge) === 300 ? 15 : 10);
                }).attr('stroke-width', d => {
                    if (d.tempHL) {
                        // 高亮节点增加边框宽度
                        return 3;
                    }
                    return 1;
                });
                
                // 高亮相关连接
                link
                    .style('stroke', l => {
                        if (hLLinks.has(l.id)) {
                            // 保持连接线原始颜色
                            if (l.upper) return '#ff9f43'; // 上层线高亮时变色
                            return color[l.source.layer+2]; // 非上层线高亮时保持原始颜色
                        }
                        if (l.upper) return 'rgba(170, 170, 170, 0.2)';
                        return '#ccc';
                    })
                    .style('stroke-width', l => {
                        if (hLLinks.has(l.id)) return 3;
                        return l.upper ? 1.5 : 2;
                    })
                    .style('stroke-opacity', l => {
                        if (hLLinks.has(l.id)) return 1;
                        return 0.2;
                    })
                    .attr('marker-end', l => {
                        if (l.upper) return null;
                        
                        let linkColor;
                        if (hLLinks.has(l.id)) {
                            // 高亮状态下使用连接线的颜色
                            linkColor = l.upper ? '#ff9f43' : color[l.source.layer+2];
                        } else {
                            // 非高亮状态使用灰色
                            linkColor = grayArrowColor;
                        }
                        return sameArrow(linkColor)
                });
            }
            
            // 检查点击的节点是否属于已高亮的集群
            function checkIfClickedClusterNode(clickedNode) {
                // 遍历所有集群
                for (const cluster of clusters) {
                    // 检查该集群是否已经被高亮（通过查看是否有节点颜色为'#ff9f43'）
                    const hasHighlightedNode = cluster.nodes.some(nodeId => {
                        const node = visNodes.find(n => n.id === nodeId);
                        return node && node.tempHL; // 使用临时标记
                    });
                    
                    // 如果集群已被高亮，且点击的节点属于该集群
                    if (hasHighlightedNode && cluster.nodes.includes(clickedNode.id)) {
                        return cluster;
                    }
                }
                return null;
            }
            
            // 检查是否有两个属于同一集群的节点被高亮
            function checkClusterHighlight() {
                // 如果没有两个或以上的节点被高亮，直接返回
                if (hLNodes.size < 2) {
                    return null;
                }
                
                // 遍历所有集群
                for (const cluster of clusters) {
                    // 计算该集群中有多少节点被高亮
                    let highlightedCount = 0;
                    for (const nodeId of cluster.nodes) {
                        if (hLNodes.has(nodeId)) {
                            highlightedCount++;
                            // 如果有两个或以上节点被高亮，返回该集群
                            if (highlightedCount >= 2) {
                                return cluster;
                            }
                        }
                    }
                }
                return null;
            }
            
            // 恢复到高亮集群出现前的高亮状态
            function restorePreClusterhL() {
                // 检查是否有保存的高亮状态
                if (!preClusterhLState) {
                    // 如果没有保存的状态，就使用resetSty
                    resetSty();
                    return;
                }
                
                // 清空当前高亮集合
                hLNodes.clear();
                hLLinks.clear();
                
                // 清除所有节点的tempHL标记
                visNodes.forEach(node => {
                    delete node.tempHL;
                });
                
                // 恢复高亮节点集合
                preClusterhLState.hLNodes.forEach(nodeId => {
                    hLNodes.add(nodeId);
                });
                
                // 恢复高亮连接线集合
                preClusterhLState.hLLinks.forEach(linkId => {
                    hLLinks.add(linkId);
                });
                
                // 恢复tempHL标记
                preClusterhLState.tempHLNodes.forEach(nodeId => {
                    const node = visNodes.find(n => n.id === nodeId);
                    if (node) {
                        node.tempHL = true;
                    }
                });
                
                // 重置保存的状态
                preClusterhLState = null;
                
                // 应用高亮样式
                applyHLSty();
            }
            


            
            
            // 验证高亮线的条件，确保线的source和target节点都是高亮状态
            function validateHLLinks() {
                // 创建一个临时集合用于存储需要保留的线ID
                const validHLLinks = new Set();
                
                // 遍历所有连接线
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    // 只有当source和target节点都是高亮状态时，才保留该线的高亮状态
                    if (hLLinks.has(link.id) && hLNodes.has(sourceId) && hLNodes.has(targetId)) {
                        validHLLinks.add(link.id);
                    }
                });
                
                // 更新高亮线集合，只保留符合条件的线
                hLLinks.clear();
                validHLLinks.forEach(linkId => hLLinks.add(linkId));
            }
            
            // 验证高亮节点的条件，确保每个高亮节点至少有一条高亮线与之相连
            function validateHLNodes() {
                // 创建一个临时集合用于存储需要保留的节点ID
                const validHLNodes = new Set();
                
                // 遍历所有高亮线，收集与之相连的节点ID
                hLLinks.forEach(linkId => {
                    const link = visLinks.find(l => l.id === linkId);
                    if (link) {
                        validHLNodes.add(link.source.id);
                        validHLNodes.add(link.target.id);
                    }
                });
                // 更新高亮节点集合，只保留符合条件的节点
                hLNodes.clear();
                validHLNodes.forEach(nodeId => hLNodes.add(nodeId));
            }
            
            // 检查是否需要重置所有样式
            function checkResetSty() {
                // 如果所有高亮集合都为空，重置所有样式
                if (hLNodes.size === 0 && hLLinks.size === 0 && activeCods.size===0) {
                    resetSty();
                    return true;
                }
                return false;
            }

            // 连接线
            function conLinks() {               
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    // 检查source和target节点是否都已高亮
                    if(!hLLinks.has(link.id)){
                        if (hLNodes.has(sourceId) && hLNodes.has(targetId)) {
                            // 将符合条件的连接线添加到高亮集合
                            hLLinks.add(link.id);
                    }}
                });
            }
            
            

            
            // 获取节点的原始颜色
            function getNodeOriColor(d) {
                if (d.upper) return 'rgba(108, 92, 231, 0.5)';
                if (d.layer <= 0) return color[d.layer+2];
                return unifiedNodeColor;
            }



           // 处理layer===0节点的点击效果（替换整段）
            function hLCodNode(nodeClicked) {
                // 找到与该节点相关的condition
                const condition = conditions.find(cond => cond.condition === nodeClicked.id);
                // 切换激活状态
                if (activeCods.has(nodeClicked.id)) {
                    // 取消激活
                    const removedColor = activeCods.get(nodeClicked.id);
                    activeCods.delete(nodeClicked.id);
                    if (removedColor && usedColors.has(removedColor)) {
                        usedColors.delete(removedColor);
                    }
                } else {
                    // 激活并分配颜色
                    activeCods.set(nodeClicked.id, generateRandomColor());
                }

            }

            

            // 保存节点的原始样式
            let oriNodeStySaved = false;
            const oriNodeColors = new Map();
            
            function saveOriNodeSty() {
                visNodes.forEach(node => {
                    oriNodeColors.set(node.id, getNodeOriColor(node));
                });
            }

            // 重置所有样式
            function resetSty() {
                // 清空高亮集合
                hLNodes.clear();
                hLLinks.clear();
                
                // 清空上一次点击的节点信息
                lastClickedNode = null;
                
                // 清空已使用的颜色集合
                usedColors.clear();
                
                // 清除所有激活的条件状态
                activeCods.clear();
                
                // 清除所有节点的临时高亮标记
                visNodes.forEach(node => {
                    delete node.tempHL;
                });
                
                // 重置保存的原始样式标记
                oriNodeStySaved = false;
                oriNodeColors.clear();
                
                // 恢复原始样式
                node.attr('fill', d => {
                    if (d.upper) return 'rgba(108, 92, 231, 0.2)';
                    if (d.layer<=0) return color[d.layer+2];
                    return unifiedNodeColor;
                }).attr('r', d => {
                    if (d.upper) return 18;
                    if (d.condition) return 12;
                    if (d.hidden1 || d.hidden2) return 10;
                    // 根据nodecharge决定半径
                    return Math.abs(d.nodecharge) === 300 ? 15 : 10;
                }).attr('stroke-width', 1);

                link
                    .style('stroke', d => {
                        if (d.upper) return 'rgba(100, 100, 100, 0.5)';
                        else  return color[d.source.layer+2];
                    })
                    .style('stroke-width', d => d.upper ? 1.5 : 2)
                    .style('stroke-opacity', 0.8)
                    .attr('marker-end', d => {
                        if (d.upper) return null;
                        
                        // 获取连接线颜色
                        const linkColor = d.upper ? 'rgba(100, 100, 100, 0.5)' : color[d.source.layer+2];                        
                        return sameArrow(linkColor)
                    });
            }

            // 已使用的颜色集合，确保不重复
            const usedColors = new Set();
            
            // 激活的条件映射，键为condition.condition，值为随机颜色
            const activeCods = new Map();
            
            // 生成随机浅色函数
            function generateRandomColor() {
                let color;
                do {
                    // 生成随机的RGB值，但确保是浅色
                    const r = Math.floor(Math.random() * 155) + 100; // 100-254
                    const g = Math.floor(Math.random() * 155) + 100; // 100-254
                    const b = Math.floor(Math.random() * 155) + 100; // 100-254
                    color = `rgb(${r}, ${g}, ${b})`;
                } while (usedColors.has(color)); // 确保颜色不重复
                
                usedColors.add(color);
                return color;
            }
            
            function getNodeCodColor(nodeId) {
/*             if (hLNodes.has(nodeId) && activeCods.size!==0){
            for (const [conditionId, color] of activeCods.entries()) {
                const cod = conditions.find(c => c.condition === conditionId);
                if (cod && (cod.condition === nodeId || cod.nodes.includes(nodeId))) {
                    return color;
                }
            }} 
            else if(hLNodes.has(nodeId)) {      
            // 默认返回原始颜色
            const node = visNodes.find(n => n.id === nodeId);
            return getNodeOriColor(node);}
            else if(!hLNodes.has(nodeId) )
            return '#ddd' */
            for (const [conditionId, color] of activeCods.entries()) {
                const cod = conditions.find(c => c.condition === conditionId);
                if (cod && (cod.condition === nodeId || cod.nodes.includes(nodeId))) {
                    if (hLNodes.size === 0)
                    return color;
                    else if (!hLNodes.has(nodeId))
                    return '#ddd';
                    else if (hLNodes.has(nodeId))
                    return color;
                }
            }
            if (hLNodes.has(nodeId)){
                const node = visNodes.find(n => n.id === nodeId);
                return getNodeOriColor(node);
            }
            else if(hLNodes.size === 0){
                const node = visNodes.find(n => n.id === nodeId);
                return getNodeOriColor(node);
            } 
            else return '#ddd'
            }

            
            // 取消节点及其周边节点的激活状态
            function unhLNeighbors(node) {
                // 检查是否是高亮的集群节点或layer===0的节点，如果是则不执行取消高亮
                if (node.tempHL || node.layer === 0) {
                    return;
                }
                
                // 找到与该节点直接相连的所有节点
                const conNodes = new Set([node.id]);
                visLinks.forEach(link => {
                    if (link.source.id === node.id) {
                        conNodes.add(link.target.id);
                    }
                    if (link.target.id === node.id) {
                        conNodes.add(link.source.id);
                    }
                });

                // 从高亮集合中移除这些节点
                conNodes.forEach(nodeId => {
                    if (hLNodes.has(nodeId)) {
                        hLNodes.delete(nodeId);
                    }
                });

                // 从高亮连接集合中移除与这些节点相关的连接
                const linksToRemove = new Set();
                visLinks.forEach(link => {
                    const sourceId = link.source.id;
                    const targetId = link.target.id;
                    
                    if (conNodes.has(sourceId) && conNodes.has(targetId)) {
                        if (hLLinks.has(link.id)) {
                            linksToRemove.add(link.id);
                        }
                    }
                });

                linksToRemove.forEach(linkId => {
                    if (hLLinks.has(linkId)) {
                        hLLinks.delete(linkId);
                    }
                });

                // 重新应用样式
                applyHLSty();
            }



            return { node, link, label };
        }

        // 拖拽函数
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 初始绘制
        drawGraph();

        // 切换隐藏节点的可见性
        const toggleButton = document.getElementById('toggleHiddenNodes');
        
        toggleButton.addEventListener('click', () => {
            hiddenNodesVisible = !hiddenNodesVisible;
            toggleButton.textContent = hiddenNodesVisible ? '隐藏节点' : '显示隐藏节点';
            
            drawGraph();
        });

        // 响应窗口大小变化
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            svg.attr('width', newWidth).attr('height', newHeight);
            
            // 重新绘制图以适应新尺寸
            drawGraph();
        });
    </script>
</body>
</html>