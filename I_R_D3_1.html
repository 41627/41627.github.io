
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>演绎系统知识图谱可视化</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .visualization {
            flex: 1;
            position: relative;
        }
        #graph {
            width: 100%;
            height: 100%;
        }
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        .link {
            stroke-opacity: 0.8;
        }
        .node-label {
            font-size: 12px;
            fill: #fff;
            text-shadow: 0 1px 2px #000;
            pointer-events: none;
        }
        .progress-container {
            position: absolute;
            top: 150px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            width: 200px;
        }
        .progress-bar {
            height: 10px;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="visualization">
            <svg id="graph"></svg>
            <div class="progress-container">
                <div>算法迭代进度:</div>
                <div class="progress-bar" id="progress-bar"></div>
                <div id="iteration-info">迭代: 0/0</div>
                <div id="convergence-info">收敛: -</div>
            </div>
        </div>
    </div>

    <script>
        // 设置尺寸和边距
        const width = window.innerWidth;
        const height = window.innerHeight - 100;
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };

        // 创建SVG元素
        const svg = d3.select('#graph')
            .attr('width', width)
            .attr('height', height);

        // 添加缩放容器
        const container = svg.append('g')
            .attr('class', 'container');

        // 定义颜色方案
        const colorScheme = d3.scaleOrdinal(d3.schemeCategory10);
        const clusterColors = {
            'cluster1': '#ff7979',
            'cluster2': '#f6e58d',
            'cluster3': '#badc58',
            'cluster4': '#7ed6df',
            'cluster5': '#e056fd'
        };

        // 模拟数据 - 节点和连接
        const nodes = [
            { id: 0, name: "根节点1", root: true, cluster: "cluster1" },
            { id: 1, name: "节点A", cluster: "cluster1" },
            { id: 2, name: "节点B", cluster: "cluster1" },
            { id: 3, name: "节点C", cluster: "cluster1" },
            { id: 4, name: "根节点2", root: true, cluster: "cluster2" },
            { id: 5, name: "节点D", cluster: "cluster2" },
            { id: 6, name: "节点E", cluster: "cluster2" },
            { id: 7, name: "节点F", cluster: "cluster2" },
            { id: 8, name: "节点G", cluster: "cluster3" },
            { id: 9, name: "节点H", cluster: "cluster3" },
            { id: 10, name: "根节点3", root: true, cluster: "cluster3" },
            { id: 11, name: "节点I", cluster: "cluster4" },
            { id: 12, name: "节点J", cluster: "cluster4" },
            { id: 13, name: "根节点4", root: true, cluster: "cluster4" },
            { id: 14, name: "节点K", cluster: "cluster5" },
            { id: 15, name: "根节点5", root: true, cluster: "cluster5" }
        ];

        const links = [
            { source: 1, target: 0, cluster: "cluster1" },
            { source: 2, target: 0, cluster: "cluster1" },
            { source: 3, target: 0, cluster: "cluster1" },
            { source: 5, target: 4, cluster: "cluster2" },
            { source: 6, target: 4, cluster: "cluster2" },
            { source: 7, target: 4, cluster: "cluster2" },
            { source: 8, target: 10, cluster: "cluster3" },
            { source: 9, target: 10, cluster: "cluster3" },
            { source: 11, target: 13, cluster: "cluster4" },
            { source: 12, target: 13, cluster: "cluster4" },
            { source: 14, target: 15, cluster: "cluster5" },
            { source: 2, target: 5, cluster: "cluster3" },
            { source: 3, target: 7, cluster: "cluster4" },
            { source: 6, target: 10, cluster: "cluster5" },
            { source: 8, target: 13, cluster: "cluster2" },
            { source: 9, target: 15, cluster: "cluster1" }
        ];

        // 预计算数据结构
        function precomputeDataStructures(nodes, links) {
            // 为每个节点添加入边和出边列表
            nodes.forEach(node => {
                node.inEdges = [];
                node.outEdges = [];
            });
            
            // 为每条边添加簇列表
            links.forEach(link => {
                link.clusters = [link.cluster];
                
                // 找到源节点和目标节点
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                
                // 更新节点的边列表
                if (sourceNode) {
                    sourceNode.outEdges.push(link);
                }
                if (targetNode) {
                    targetNode.inEdges.push(link);
                }
            });
            
            return { nodes, links };
        }

        // 初始化I和R值
        function initializeIRValues(nodes, links) {
            // 初始化节点的I值
            nodes.forEach(node => {
                const outCount = node.outEdges.length;
                const inCount = node.inEdges.length;
                node.I = (outCount + 1) / (inCount + 1);
            });
            
            // 初始化边的R值
            links.forEach(link => {
                link.R = 1;
            });
        }

        // 迭代算法参数
        const algorithmParams = {
            alpha: 1.0,
            beta: 1.0,
            gamma: 1.0,
            delta: 1.0,
            epsilon: 0.001,
            maxIterations: 100
        };

        // 运行迭代算法
        function runIterativeAlgorithm(nodes, links, params) {
            const { alpha, beta, gamma, delta, epsilon, maxIterations } = params;
            let iteration = 0;
            let converged = false;
            
            // 获取所有唯一的簇
            const allClusters = [...new Set(links.flatMap(link => link.clusters))];
            
            // 保存上一次迭代的值用于收敛检查
            const prevI = new Map(nodes.map(node => [node.id, node.I]));
            const prevR = new Map(links.map(link => [link, link.R]));
            
            while (iteration < maxIterations && !converged) {
                iteration++;
                
                // 更新进度条和信息
                updateProgress(iteration, maxIterations);
                
                // 步骤1: 计算当前i值
                const iValues = new Map();
                nodes.forEach(node => {
                    iValues.set(node.id, 1 / node.I);
                });
                
                // 步骤2: 预计算每个簇的Tc
                const Tc = new Map();
                allClusters.forEach(cluster => {
                    let sum = 0;
                    // 找到属于该簇的所有边的目标节点
                    const clusterLinks = links.filter(link => link.clusters.includes(cluster));
                    const targetNodes = new Set(clusterLinks.map(link => 
                        nodes.find(n => n.id === link.target)
                    ));
                    
                    targetNodes.forEach(node => {
                        if (node) sum += iValues.get(node.id);
                    });
                    
                    Tc.set(cluster, sum);
                });
                
                // 步骤3: 计算每条边的Se
                links.forEach(link => {
                    let Se = 0;
                    link.clusters.forEach(cluster => {
                        Se += Tc.get(cluster) || 0;
                    });
                    link.Se = Se;
                });
                
                // 步骤4: 更新R值
                let totalR = 0;
                links.forEach(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode) {
                        link.R = gamma * link.Se + delta * (sourceNode.I + targetNode.I);
                        totalR += link.R;
                    }
                });
                
                // 步骤5: 归一化R值
                links.forEach(link => {
                    link.R = link.R / totalR;
                });
                
                // 步骤6: 更新I值
                let totalI = 0;
                nodes.forEach(node => {
                    const Rout = node.outEdges.reduce((sum, edge) => sum + edge.R, 0);
                    const Rin = node.inEdges.reduce((sum, edge) => sum + edge.R, 0);
                    
                    node.I = alpha * Rout + beta * Rin;
                    totalI += node.I;
                });
                
                // 步骤7: 归一化I值
                nodes.forEach(node => {
                    node.I = node.I / totalI;
                });
                
                // 步骤8: 检查收敛
                let maxDeltaI = 0;
                let maxDeltaR = 0;
                
                nodes.forEach(node => {
                    const deltaI = Math.abs(node.I - prevI.get(node.id));
                    if (deltaI > maxDeltaI) maxDeltaI = deltaI;
                    prevI.set(node.id, node.I);
                });
                
                links.forEach(link => {
                    const deltaR = Math.abs(link.R - prevR.get(link));
                    if (deltaR > maxDeltaR) maxDeltaR = deltaR;
                    prevR.set(link, link.R);
                });
                
                converged = maxDeltaI < epsilon && maxDeltaR < epsilon;
                
                // 更新收敛信息
                updateConvergenceInfo(iteration, maxDeltaI, maxDeltaR, converged);
            }
            
            return { iteration, converged };
        }

        // 更新进度条
        function updateProgress(iteration, maxIterations) {
            const progressPercent = (iteration / maxIterations) * 100;
            d3.select('#progress-bar')
                .style('width', `${progressPercent}%`);
                
            d3.select('#iteration-info')
                .text(`迭代: ${iteration}/${maxIterations}`);
        }

        // 更新收敛信息
        function updateConvergenceInfo(iteration, maxDeltaI, maxDeltaR, converged) {
            d3.select('#convergence-info')
                .html(`收敛: ${converged ? '是' : '否'}<br>
                       ΔI: ${maxDeltaI.toExponential(2)}<br>
                       ΔR: ${maxDeltaR.toExponential(2)}`);
        }

        // 应用I和R值到力导向图
        function applyIRValuesToSimulation(simulation, nodes, links) {
            // 根据I值调整节点电荷和半径
            simulation.force('charge', d3.forceManyBody()
                .strength(d => -300 * (d.I || 1))
            );
            
            // 根据R值调整连接距离
            simulation.force('link', d3.forceLink(links)
                .id(d => d.id)
                .distance(link => 100 * (link.R || 1))
            );
            
            // 重新启动模拟
            simulation.alpha(0.3).restart();
            
            // 更新节点半径
            d3.selectAll('.node')
                .attr('r', d => d.root ? 15 + 10 * (d.I || 1) : 10 + 5 * (d.I || 1));
        }

        // 预处理数据结构
        const { nodes: processedNodes, links: processedLinks } = precomputeDataStructures(nodes, links);

        // 初始化I和R值
        initializeIRValues(processedNodes, processedLinks);

            
        // 运行迭代算法
        const result = runIterativeAlgorithm(processedNodes, processedLinks, algorithmParams);

        // 创建力导向图
        let simulation = d3.forceSimulation(processedNodes)
            .force('link', d3.forceLink(processedLinks).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(40));

            
        // 应用计算结果到力导向图
        applyIRValuesToSimulation(simulation, processedNodes, processedLinks);
            
        // 显示算法结果
        alert(`算法完成于 ${result.iteration} 次迭代，${result.converged ? '已收敛' : '未收敛'}`);


        // 绘制连接线
        const link = container.append('g')
            .attr('class', 'links')
            .selectAll('line')
            .data(processedLinks)
            .enter()
            .append('line')
            .attr('class', 'link')
            .attr('stroke', d => clusterColors[d.cluster])
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrowhead)');

        // 添加箭头标记
        svg.append('defs').selectAll('marker')
            .data(['arrowhead'])
            .enter().append('marker')
            .attr('id', d => d)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 25)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('class', 'arrow-head')
            .attr('fill', d => '#999');

        // 绘制节点
        const node = container.append('g')
            .attr('class', 'nodes')
            .selectAll('circle')
            .data(processedNodes)
            .enter()
            .append('circle')
            .attr('class', 'node')
            .attr('r', d => d.root ? 15 : 10)
            .attr('fill', d => d.root ? '#ff4757' : '#5352ed')
            .call(d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded));

        // 添加节点标签
        const label = container.append('g')
            .attr('class', 'labels')
            .selectAll('text')
            .data(processedNodes)
            .enter()
            .append('text')
            .attr('class', 'node-label')
            .text(d => d.name)
            .attr('text-anchor', 'middle')
            .attr('dy', d => d.root ? -20 : -15);



        // 力导向图更新函数
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });

        // 拖拽函数
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }




        // 添加鼠标悬停高亮效果
        node.on('mouseover', function(event, d) {
            // 高亮当前节点
            d3.select(this).attr('r', d => d.root ? 20 : 15).attr('fill', '#ff9f43');
            
            // 高亮与之相关的连接
            link
                .style('stroke', l => (l.source === d || l.target === d) ? clusterColors[l.cluster] : '#ddd')
                .style('stroke-width', l => (l.source === d || l.target === d) ? 3 : 1);
        });

        node.on('mouseout', function(event, d) {
            // 恢复节点样式
            d3.select(this).attr('r', d => d.root ? 15 : 10).attr('fill', d => d.root ? '#ff4757' : '#5352ed');
            
            // 恢复连接样式
            link
                .style('stroke', d => clusterColors[d.cluster])
                .style('stroke-width', 2);
        });

        // 响应窗口大小变化
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight - 100;
            
            svg.attr('width', newWidth).attr('height', newHeight);
            simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.alpha(0.3).restart();
        });
    </script>
</body>
</html>
